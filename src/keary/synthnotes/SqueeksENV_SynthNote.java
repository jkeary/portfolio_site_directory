package keary.synthnotes;
import java.io.*;
import com.softsynth.jsyn.*;
/**************
** WARNING - this code automatically generated by Wire.
** The real source is probably a Wire patch.
** Do NOT edit this file unless you copy it to another directory and change the name.
** Otherwise it is likely to get clobbered the next time you
** export Java source code from Wire.
**
** Wire is available from: http://www.softsynth.com/wire/
*/
public class SqueeksENV_SynthNote extends SynthNote
{
    // Declare units and ports.
    public SynthInput Sin1ModFreq;
    SineOscillator sinOsc;
    SineOscillator sinOsc2;
    SineOscillator sinOsc3;
    public SynthInput Sin2RangeAmp;
    public SynthInput Sin3ModFreq;
    EnvelopePlayer envPlay;
    SynthEnvelope envelope;
    MultiplyUnit mult;

    public SqueeksENV_SynthNote()
    {
        this( Synth.getSharedContext() );
    }
    public SqueeksENV_SynthNote( SynthContext synthContext )
    {
        super( synthContext );
        // Create unit generators.
        add( sinOsc = new SineOscillator(synthContext) );
        add( sinOsc2 = new SineOscillator(synthContext) );
        add( sinOsc3 = new SineOscillator(synthContext) );
        add( envPlay = new EnvelopePlayer(synthContext) );
        double[] envelopeData = {
            0.0, 0.0125, 
            0.08709756199800887, 0.04583333333333333, 
            9.83364911652679, 0.0, 
        };
        envelope = new SynthEnvelope( synthContext, envelopeData );
        envelopeData = null;
        envelope.setSustainLoop( -1, -1 );
        envelope.setReleaseLoop( -1, -1 );
        add( mult = new MultiplyUnit(synthContext) );
        // Connect units and ports.

        addPort( Sin1ModFreq = sinOsc.frequency, "Sin1ModFreq" );
        Sin1ModFreq.setup( 0.0, 5.0, 5.0 );

        addPort( amplitude = mult.inputA, "amplitude" );
        amplitude.setup( 0.0, 1.0, 1.0 );
        addPort( output = envPlay.output, "output" );
        sinOsc.phase.set( 0, 0.5290517631482035 );
        sinOsc.output.connect( sinOsc2.frequency);
        sinOsc2.phase.set( 0, 0.48606932521252044 );
        sinOsc2.output.connect( sinOsc3.amplitude);
        sinOsc3.phase.set( 0, -0.4957625455954421 );
        sinOsc3.output.connect( envPlay.amplitude);

        addPort( Sin2RangeAmp = sinOsc2.amplitude, "Sin2RangeAmp" );
        Sin2RangeAmp.setup( 0.0, 2.55, 5.0 );

        addPort( Sin3ModFreq = sinOsc3.frequency, "Sin3ModFreq" );
        Sin3ModFreq.setup( 0.0, 5.0, 10.0 );
        envPlay.rate.set( 0, 1.0 );
        mult.inputB.set( 0, 20000.0 );
        mult.output.connect( sinOsc.amplitude);
    }
    
    public void setStage( int time, int stage )
    {
        switch( stage )
        {
        case 0:
            envPlay.envelopePort.clear( time );
            envPlay.envelopePort.queueOn( time, envelope );
            start( time );
            break;
        case 1:
            envPlay.envelopePort.queueOff( time, envelope );
            break;
        default:
            break;
        }
    }
}
